<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WHAM HUD - AR Glasses</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Halo glasses frame container */
        #halo-frame {
            position: relative;
            width: 640px;
            height: 400px;
            background: #000;
            border: 2px solid #333;
            border-radius: 8px;
            overflow: hidden;
        }

        /* AR canvas - Halo OLED: 640x400 */
        #hud-canvas {
            width: 640px;
            height: 400px;
            pointer-events: none;
        }

        /* Resolution label */
        #resolution-label {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.3);
            font-size: 11px;
        }

        /* Control panel */
        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            z-index: 100;
        }

        #controls h3 {
            color: #00FFFF;
            margin-bottom: 10px;
            font-size: 14px;
            font-weight: 500;
        }

        #controls input[type="text"] {
            width: calc(100% - 80px);
            padding: 10px 12px;
            background: #111;
            border: 1px solid rgba(0, 255, 255, 0.4);
            color: #fff;
            font-family: inherit;
            font-size: 13px;
            border-radius: 4px;
        }

        #controls input[type="text"]:focus {
            outline: none;
            border-color: #00FFFF;
        }

        #controls button {
            padding: 10px 16px;
            background: #00FFFF;
            color: #000;
            border: none;
            font-family: inherit;
            font-weight: 600;
            cursor: pointer;
            border-radius: 4px;
            margin-left: 10px;
        }

        #controls button:hover {
            background: #00DDDD;
        }

        #status {
            margin-top: 10px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 11px;
        }

        #status.connected {
            color: #00FF80;
        }

        #status.disconnected {
            color: #FF4040;
        }

        #mode-selector {
            margin-top: 10px;
        }

        #mode-selector label {
            color: rgba(255, 255, 255, 0.7);
            margin-right: 15px;
            font-size: 11px;
            cursor: pointer;
        }

        #mode-selector input[type="radio"] {
            margin-right: 4px;
            accent-color: #00FFFF;
        }

        /* Fullscreen toggle */
        #fullscreen-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 8px 12px;
            background: rgba(0, 255, 255, 0.1);
            color: #00FFFF;
            border: 1px solid rgba(0, 255, 255, 0.4);
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
            border-radius: 4px;
            z-index: 100;
        }

        #fullscreen-btn:hover {
            background: rgba(0, 255, 255, 0.2);
        }

        /* Preset buttons */
        .preset-btn {
            padding: 6px 12px;
            margin-right: 8px;
            margin-top: 10px;
            background: transparent;
            color: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .preset-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: #00FFFF;
            color: #00FFFF;
        }
    </style>
</head>
<body>
    <div id="resolution-label">Brilliant Labs Halo - 640x400 RGB OLED</div>

    <div id="halo-frame">
        <canvas id="hud-canvas"></canvas>
    </div>

    <button id="fullscreen-btn">Fullscreen</button>

    <div id="controls">
        <h3>WHAM HUD</h3>
        <input type="text" id="message-input" placeholder="Ask: 'What are the odds with AK vs QQ?'" />
        <button id="send-btn">Send</button>

        <div id="mode-selector">
            <label><input type="radio" name="mode" value="all" checked> All</label>
            <label><input type="radio" name="mode" value="poker"> Poker</label>
            <label><input type="radio" name="mode" value="homework"> Homework</label>
            <label><input type="radio" name="mode" value="code"> Code</label>
        </div>

        <div>
            <button class="preset-btn" onclick="sendPreset('poker')">Poker Demo</button>
            <button class="preset-btn" onclick="sendPreset('math')">Math Demo</button>
            <button class="preset-btn" onclick="sendPreset('code')">Code Demo</button>
            <button class="preset-btn" onclick="sendPreset('calendar')">Calendar</button>
        </div>

        <div id="status">Connecting...</div>
    </div>

    <script>
        // WHAM HUD - JARVIS/Apple Minimal Design
        // Halo OLED: 640x400

        const HUD = {
            WIDTH: 640,
            HEIGHT: 400,
            COLORS: {
                primary: '#00FFFF',      // Cyan - headers, borders, branding
                text: '#FFFFFF',          // White - all content
                textDim: 'rgba(255, 255, 255, 0.5)',
                background: '#000000',    // True OLED black
                // Accents - ONLY for emphasis
                error: '#FF4040',
                warning: '#FFBF00',
                success: '#00FF80',
            },
            FONT: {
                header: 'bold 16px Menlo, Monaco, monospace',
                content: '14px Menlo, Monaco, monospace',
                small: '12px Menlo, Monaco, monospace',
                tiny: '10px Menlo, Monaco, monospace',
            }
        };

        class HUDRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.messages = [];
                this.maxMessages = 3;
                this.connected = false;
                this.currentMode = 'all';
                this.init();
            }

            init() {
                this.canvas.width = HUD.WIDTH;
                this.canvas.height = HUD.HEIGHT;
                this.render();
            }

            addMessage(text, type = 'info', emphasis = false) {
                this.messages.unshift({
                    text,
                    type,
                    emphasis,
                    timestamp: Date.now(),
                    opacity: 0  // Start invisible for fade-in
                });
                if (this.messages.length > this.maxMessages) {
                    this.messages.pop();
                }
            }

            clear() {
                this.ctx.fillStyle = HUD.COLORS.background;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            render() {
                this.clear();
                const ctx = this.ctx;

                // Fade in messages
                this.messages.forEach(msg => {
                    if (msg.opacity < 1) msg.opacity = Math.min(1, msg.opacity + 0.05);
                });

                // === HEADER (40px) ===
                this.renderHeader(ctx);

                // === MAIN CONTENT (280px) ===
                this.renderMessages(ctx);

                // === FOOTER (40px) ===
                this.renderFooter(ctx);
            }

            renderHeader(ctx) {
                // WHAM branding - left
                ctx.font = HUD.FONT.header;
                ctx.fillStyle = HUD.COLORS.primary;
                ctx.fillText('WHAM', 24, 28);

                // Connection status - right
                ctx.font = HUD.FONT.small;
                ctx.fillStyle = this.connected ? HUD.COLORS.success : HUD.COLORS.error;
                const statusText = this.connected ? 'LIVE' : 'OFFLINE';
                const statusWidth = ctx.measureText(statusText).width;
                ctx.fillText(statusText, HUD.WIDTH - 24 - statusWidth, 28);

                // Time - center
                const time = new Date().toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                });
                ctx.font = HUD.FONT.small;
                ctx.fillStyle = HUD.COLORS.textDim;
                const timeWidth = ctx.measureText(time).width;
                ctx.fillText(time, (HUD.WIDTH - timeWidth) / 2, 28);

                // Header separator line
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(24, 42);
                ctx.lineTo(HUD.WIDTH - 24, 42);
                ctx.stroke();
            }

            renderMessages(ctx) {
                const startY = 70;
                const cardHeight = 70;
                const cardMargin = 12;
                const cardPadding = 14;

                this.messages.forEach((msg, index) => {
                    const y = startY + index * (cardHeight + cardMargin);
                    const alpha = msg.opacity * (1 - index * 0.15);

                    // Determine border color based on type
                    let borderColor = HUD.COLORS.primary;
                    let textColor = HUD.COLORS.text;

                    if (msg.type === 'error') {
                        borderColor = HUD.COLORS.error;
                        textColor = HUD.COLORS.error;
                    } else if (msg.type === 'warning') {
                        borderColor = HUD.COLORS.warning;
                    } else if (msg.type === 'success') {
                        borderColor = HUD.COLORS.success;
                    }

                    // Card background - subtle
                    ctx.fillStyle = `rgba(20, 25, 30, ${alpha * 0.8})`;
                    ctx.fillRect(20, y, HUD.WIDTH - 40, cardHeight);

                    // Card border - 1px
                    ctx.strokeStyle = this.colorWithAlpha(borderColor, alpha * 0.7);
                    ctx.lineWidth = 1;
                    ctx.strokeRect(20, y, HUD.WIDTH - 40, cardHeight);

                    // Message text
                    ctx.font = HUD.FONT.content;
                    ctx.fillStyle = this.colorWithAlpha(textColor, alpha);

                    // Word wrap
                    const maxWidth = HUD.WIDTH - 80;
                    const words = msg.text.split(' ');
                    let line = '';
                    let lineY = y + cardPadding + 14;
                    const lineHeight = 20;

                    words.forEach(word => {
                        const testLine = line + word + ' ';
                        if (ctx.measureText(testLine).width > maxWidth && line !== '') {
                            ctx.fillText(line.trim(), 20 + cardPadding, lineY);
                            line = word + ' ';
                            lineY += lineHeight;
                        } else {
                            line = testLine;
                        }
                    });
                    ctx.fillText(line.trim(), 20 + cardPadding, lineY);

                    // Timestamp - bottom right of card
                    const age = Math.floor((Date.now() - msg.timestamp) / 1000);
                    const ageStr = age < 60 ? `${age}s ago` : `${Math.floor(age / 60)}m ago`;
                    ctx.font = HUD.FONT.tiny;
                    ctx.fillStyle = this.colorWithAlpha(HUD.COLORS.textDim, alpha);
                    const ageWidth = ctx.measureText(ageStr).width;
                    ctx.fillText(ageStr, HUD.WIDTH - 24 - ageWidth, y + cardHeight - 10);
                });

                // Empty state
                if (this.messages.length === 0) {
                    ctx.font = HUD.FONT.content;
                    ctx.fillStyle = HUD.COLORS.textDim;
                    ctx.textAlign = 'center';
                    ctx.fillText('Waiting for input...', HUD.WIDTH / 2, HUD.HEIGHT / 2);
                    ctx.textAlign = 'left';
                }
            }

            renderFooter(ctx) {
                const footerY = HUD.HEIGHT - 30;

                // Footer separator line
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(24, footerY - 12);
                ctx.lineTo(HUD.WIDTH - 24, footerY - 12);
                ctx.stroke();

                // Mode indicator - left
                ctx.font = HUD.FONT.tiny;
                ctx.fillStyle = HUD.COLORS.textDim;
                ctx.fillText(`Mode: ${this.currentMode.toUpperCase()}`, 24, footerY);

                // Processing indicator - right (if applicable)
                if (this.processing) {
                    ctx.fillStyle = HUD.COLORS.primary;
                    ctx.fillText('Processing...', HUD.WIDTH - 100, footerY);
                }
            }

            colorWithAlpha(hex, alpha) {
                // Handle rgba strings
                if (hex.startsWith('rgba')) return hex;

                // Convert hex to rgba
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }

            setConnected(connected) {
                this.connected = connected;
            }

            setMode(mode) {
                this.currentMode = mode;
            }

            setProcessing(processing) {
                this.processing = processing;
            }
        }

        // WebSocket HUD Client
        class HUDClient {
            constructor(renderer) {
                this.renderer = renderer;
                this.ws = null;
                this.reconnectDelay = 1000;
                this.maxReconnectDelay = 30000;
                this.connect();
            }

            connect() {
                const wsUrl = `ws://${window.location.hostname}:8000/ws/hud`;
                this.ws = new WebSocket(wsUrl);

                this.ws.onopen = () => {
                    console.log('HUD connected');
                    this.renderer.setConnected(true);
                    this.renderer.addMessage('Connected to WHAM', 'success');
                    this.updateStatus('Connected', true);
                    this.reconnectDelay = 1000;

                    const mode = document.querySelector('input[name="mode"]:checked').value;
                    this.subscribeMode(mode);
                };

                this.ws.onclose = () => {
                    console.log('HUD disconnected');
                    this.renderer.setConnected(false);
                    this.updateStatus('Disconnected - reconnecting...', false);

                    setTimeout(() => this.connect(), this.reconnectDelay);
                    this.reconnectDelay = Math.min(this.reconnectDelay * 2, this.maxReconnectDelay);
                };

                this.ws.onerror = (error) => {
                    console.error('HUD error:', error);
                };

                this.ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        this.handleMessage(data);
                    } catch (e) {
                        console.error('Parse error:', e);
                    }
                };
            }

            updateStatus(text, connected) {
                const status = document.getElementById('status');
                status.textContent = text;
                status.className = connected ? 'connected' : 'disconnected';
            }

            handleMessage(data) {
                console.log('Received:', data);

                switch (data.type) {
                    case 'subscribed':
                        this.renderer.setMode(data.mode);
                        break;

                    case 'hud_update':
                        this.handleUpdate(data.data);
                        break;

                    case 'agent_response':
                        this.handleUpdate(data.data);
                        break;

                    case 'pong':
                    case 'connected':
                        break;

                    case 'error':
                        this.renderer.addMessage(data.message, 'error');
                        break;
                }

                this.renderer.setProcessing(false);
            }

            handleUpdate(result) {
                // All messages look the same - no per-tool colors
                // Only use error/warning/success for emphasis
                let type = 'info';

                if (result.success === false) {
                    type = 'error';
                } else if (result.response && result.response.toLowerCase().includes('warning')) {
                    type = 'warning';
                }

                const text = result.response || JSON.stringify(result);
                this.renderer.addMessage(text, type);
            }

            subscribeMode(mode) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'subscribe_mode',
                        mode: mode
                    }));
                }
            }

            sendAgentRequest(message) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.renderer.addMessage(`> ${message}`, 'info');
                    this.renderer.setProcessing(true);
                    this.ws.send(JSON.stringify({
                        type: 'agent_request',
                        message: message
                    }));
                } else {
                    this.renderer.addMessage('Not connected', 'error');
                }
            }
        }

        // Initialize
        const canvas = document.getElementById('hud-canvas');
        const renderer = new HUDRenderer(canvas);
        const client = new HUDClient(renderer);

        // Animation loop (60fps)
        function animate() {
            renderer.render();
            requestAnimationFrame(animate);
        }
        animate();

        // UI Controls
        document.getElementById('send-btn').addEventListener('click', () => {
            const input = document.getElementById('message-input');
            if (input.value.trim()) {
                client.sendAgentRequest(input.value.trim());
                input.value = '';
            }
        });

        document.getElementById('message-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('send-btn').click();
            }
        });

        document.querySelectorAll('input[name="mode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                client.subscribeMode(e.target.value);
            });
        });

        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                document.documentElement.requestFullscreen();
            }
        });

        // Presets
        window.sendPreset = function(type) {
            const presets = {
                poker: "What are the odds if I have AK suited vs QQ preflop?",
                math: "What's the derivative of x^3 + 2x^2?",
                code: "Run python: print('Hello from HUD!')",
                calendar: "List my events for today"
            };
            client.sendAgentRequest(presets[type]);
        };
    </script>
</body>
</html>
